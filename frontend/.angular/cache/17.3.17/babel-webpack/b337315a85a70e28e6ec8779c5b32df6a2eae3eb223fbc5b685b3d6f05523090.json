{"ast":null,"code":"import { BehaviorSubject, interval } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TargetService {\n  constructor(http) {\n    this.http = http;\n    this.targetsSubject = new BehaviorSubject([]);\n    this.isConnectedSubject = new BehaviorSubject(false);\n    this.targets$ = this.targetsSubject.asObservable();\n    this.isConnected$ = this.isConnectedSubject.asObservable();\n    this.apiUrl = 'http://localhost:8000';\n    this.wsUrl = 'ws://localhost:8000/ws';\n  }\n  // Simulate WebSocket stream using RxJS interval\n  startSimulatedStream() {\n    // Stop any existing stream first\n    this.stopSimulatedStream();\n    this.isConnectedSubject.next(true);\n    this.streamSubscription = interval(1000).pipe(map(() => this.generateRandomTarget())).subscribe(target => {\n      const currentTargets = this.targetsSubject.value;\n      const updatedTargets = [target, ...currentTargets].slice(0, 50); // Keep last 50 targets\n      this.targetsSubject.next(updatedTargets);\n    });\n  }\n  stopSimulatedStream() {\n    if (this.streamSubscription) {\n      this.streamSubscription.unsubscribe();\n      this.streamSubscription = undefined;\n    }\n    this.isConnectedSubject.next(false);\n  }\n  // REST API methods\n  getTargets() {\n    return this.http.get(`${this.apiUrl}/targets`);\n  }\n  addTargets(targets) {\n    return this.http.post(`${this.apiUrl}/targets`, {\n      targets\n    });\n  }\n  // Filter targets by classification\n  getFilteredTargets(classification) {\n    return this.targets$.pipe(map(targets => {\n      if (!classification) return targets;\n      return targets.filter(target => target.classification === classification);\n    }));\n  }\n  // Generate random target for simulation\n  generateRandomTarget() {\n    const classifications = ['hostile', 'friendly'];\n    const names = ['Alpha', 'Bravo', 'Charlie', 'Delta', 'Echo', 'Foxtrot', 'Golf', 'Hotel'];\n    return {\n      id: Math.random().toString(36).substr(2, 9),\n      name: `${names[Math.floor(Math.random() * names.length)]}-${Math.floor(Math.random() * 1000)}`,\n      heading: Math.floor(Math.random() * 360),\n      timestamp: new Date().toISOString(),\n      classification: classifications[Math.floor(Math.random() * classifications.length)]\n    };\n  }\n  // Clear all targets\n  clearTargets() {\n    this.targetsSubject.next([]);\n  }\n  ngOnDestroy() {\n    this.stopSimulatedStream();\n  }\n  static {\n    this.ɵfac = function TargetService_Factory(t) {\n      return new (t || TargetService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TargetService,\n      factory: TargetService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["BehaviorSubject","interval","map","TargetService","constructor","http","targetsSubject","isConnectedSubject","targets$","asObservable","isConnected$","apiUrl","wsUrl","startSimulatedStream","stopSimulatedStream","next","streamSubscription","pipe","generateRandomTarget","subscribe","target","currentTargets","value","updatedTargets","slice","unsubscribe","undefined","getTargets","get","addTargets","targets","post","getFilteredTargets","classification","filter","classifications","names","id","Math","random","toString","substr","name","floor","length","heading","timestamp","Date","toISOString","clearTargets","ngOnDestroy","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["C:\\Users\\tomer\\Desktop\\mini-target-tracker\\frontend\\src\\app\\services\\target.service.ts"],"sourcesContent":["import { Injectable, OnDestroy } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { BehaviorSubject, Observable, interval, Subscription } from 'rxjs';\r\nimport { map, switchMap } from 'rxjs/operators';\r\nimport { Target } from '../models/target.model';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class TargetService implements OnDestroy {\r\n  private targetsSubject = new BehaviorSubject<Target[]>([]);\r\n  private isConnectedSubject = new BehaviorSubject<boolean>(false);\r\n  private streamSubscription?: Subscription;\r\n  \r\n  public targets$ = this.targetsSubject.asObservable();\r\n  public isConnected$ = this.isConnectedSubject.asObservable();\r\n\r\n  private apiUrl = 'http://localhost:8000';\r\n  private wsUrl = 'ws://localhost:8000/ws';\r\n\r\n  constructor(private http: HttpClient) {}\r\n\r\n  // Simulate WebSocket stream using RxJS interval\r\n  startSimulatedStream(): void {\r\n    // Stop any existing stream first\r\n    this.stopSimulatedStream();\r\n    \r\n    this.isConnectedSubject.next(true);\r\n    \r\n    this.streamSubscription = interval(1000).pipe(\r\n      map(() => this.generateRandomTarget())\r\n    ).subscribe(target => {\r\n      const currentTargets = this.targetsSubject.value;\r\n      const updatedTargets = [target, ...currentTargets].slice(0, 50); // Keep last 50 targets\r\n      this.targetsSubject.next(updatedTargets);\r\n    });\r\n  }\r\n\r\n  stopSimulatedStream(): void {\r\n    if (this.streamSubscription) {\r\n      this.streamSubscription.unsubscribe();\r\n      this.streamSubscription = undefined;\r\n    }\r\n    this.isConnectedSubject.next(false);\r\n  }\r\n\r\n  // REST API methods\r\n  getTargets(): Observable<{targets: Target[], count: number}> {\r\n    return this.http.get<{targets: Target[], count: number}>(`${this.apiUrl}/targets`);\r\n  }\r\n\r\n  addTargets(targets: Target[]): Observable<any> {\r\n    return this.http.post(`${this.apiUrl}/targets`, { targets });\r\n  }\r\n\r\n  // Filter targets by classification\r\n  getFilteredTargets(classification?: 'hostile' | 'friendly'): Observable<Target[]> {\r\n    return this.targets$.pipe(\r\n      map(targets => {\r\n        if (!classification) return targets;\r\n        return targets.filter(target => target.classification === classification);\r\n      })\r\n    );\r\n  }\r\n\r\n  // Generate random target for simulation\r\n  private generateRandomTarget(): Target {\r\n    const classifications: ('hostile' | 'friendly')[] = ['hostile', 'friendly'];\r\n    const names = ['Alpha', 'Bravo', 'Charlie', 'Delta', 'Echo', 'Foxtrot', 'Golf', 'Hotel'];\r\n    \r\n    return {\r\n      id: Math.random().toString(36).substr(2, 9),\r\n      name: `${names[Math.floor(Math.random() * names.length)]}-${Math.floor(Math.random() * 1000)}`,\r\n      heading: Math.floor(Math.random() * 360),\r\n      timestamp: new Date().toISOString(),\r\n      classification: classifications[Math.floor(Math.random() * classifications.length)]\r\n    };\r\n  }\r\n\r\n  // Clear all targets\r\n  clearTargets(): void {\r\n    this.targetsSubject.next([]);\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.stopSimulatedStream();\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}