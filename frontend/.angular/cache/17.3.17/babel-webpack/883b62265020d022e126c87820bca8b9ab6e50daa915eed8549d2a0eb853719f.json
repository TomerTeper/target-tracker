{"ast":null,"code":"import { signal, computed } from '@angular/core';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TargetService {\n  // Filtered targets computed signal\n  getFilteredTargets(classification) {\n    return computed(() => {\n      const targets = this.targets();\n      if (!classification) return targets;\n      return targets.filter(target => target.classification === classification);\n    });\n  }\n  constructor(http) {\n    this.http = http;\n    // Signals\n    this.targetsSignal = signal([]);\n    this.isConnectedSignal = signal(false);\n    // Computed signals\n    this.targets = this.targetsSignal.asReadonly();\n    this.isConnected = this.isConnectedSignal.asReadonly();\n    this.targetCount = computed(() => this.targets().length);\n    this.apiUrl = 'http://localhost:8000';\n    this.wsUrl = 'ws://localhost:8000/ws';\n  }\n  // Connect to real WebSocket stream\n  startWebSocketStream() {\n    // Stop any existing connection first\n    this.stopWebSocketStream();\n    try {\n      this.wsConnection = new WebSocket(this.wsUrl);\n      this.wsConnection.onopen = () => {\n        this.isConnectedSignal.set(true);\n        console.log('WebSocket connected to backend');\n      };\n      this.wsConnection.onmessage = event => {\n        try {\n          const target = JSON.parse(event.data);\n          const currentTargets = this.targetsSignal();\n          const updatedTargets = [target, ...currentTargets].slice(0, 50); // Keep last 50 targets\n          this.targetsSignal.set(updatedTargets);\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n      this.wsConnection.onerror = error => {\n        console.error('WebSocket error:', error);\n        this.isConnectedSignal.set(false);\n      };\n      this.wsConnection.onclose = () => {\n        console.log('WebSocket connection closed');\n        this.isConnectedSignal.set(false);\n      };\n    } catch (error) {\n      console.error('Failed to connect to WebSocket:', error);\n      this.isConnectedSignal.set(false);\n    }\n  }\n  stopWebSocketStream() {\n    if (this.wsConnection) {\n      this.wsConnection.close();\n      this.wsConnection = undefined;\n    }\n    this.isConnectedSignal.set(false);\n  }\n  // REST API methods\n  getTargets() {\n    return this.http.get(`${this.apiUrl}/targets`);\n  }\n  addTargets(targets) {\n    return this.http.post(`${this.apiUrl}/targets`, {\n      targets\n    });\n  }\n  // Clear all targets\n  clearTargets() {\n    this.targetsSignal.set([]);\n  }\n  static {\n    this.ɵfac = function TargetService_Factory(t) {\n      return new (t || TargetService)(i0.ɵɵinject(i1.HttpClient));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: TargetService,\n      factory: TargetService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["signal","computed","TargetService","getFilteredTargets","classification","targets","filter","target","constructor","http","targetsSignal","isConnectedSignal","asReadonly","isConnected","targetCount","length","apiUrl","wsUrl","startWebSocketStream","stopWebSocketStream","wsConnection","WebSocket","onopen","set","console","log","onmessage","event","JSON","parse","data","currentTargets","updatedTargets","slice","error","onerror","onclose","close","undefined","getTargets","get","addTargets","post","clearTargets","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["C:\\Users\\tomer\\Desktop\\mini-target-tracker\\frontend\\src\\app\\services\\target.service.ts"],"sourcesContent":["import { Injectable, signal, computed, effect } from '@angular/core';\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { Target } from '../models/target.model';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class TargetService {\r\n  // Signals\r\n  private targetsSignal = signal<Target[]>([]);\r\n  private isConnectedSignal = signal<boolean>(false);\r\n  private wsConnection?: WebSocket;\r\n\r\n  // Computed signals\r\n  public targets = this.targetsSignal.asReadonly();\r\n  public isConnected = this.isConnectedSignal.asReadonly();\r\n  public targetCount = computed(() => this.targets().length);\r\n\r\n  // Filtered targets computed signal\r\n  public getFilteredTargets(classification?: 'hostile' | 'friendly') {\r\n    return computed(() => {\r\n      const targets = this.targets();\r\n      if (!classification) return targets;\r\n      return targets.filter(target => target.classification === classification);\r\n    });\r\n  }\r\n\r\n  private apiUrl = 'http://localhost:8000';\r\n  private wsUrl = 'ws://localhost:8000/ws';\r\n\r\n  constructor(private http: HttpClient) {}\r\n\r\n  // Connect to real WebSocket stream\r\n  startWebSocketStream(): void {\r\n    // Stop any existing connection first\r\n    this.stopWebSocketStream();\r\n    \r\n    try {\r\n      this.wsConnection = new WebSocket(this.wsUrl);\r\n      \r\n      this.wsConnection.onopen = () => {\r\n        this.isConnectedSignal.set(true);\r\n        console.log('WebSocket connected to backend');\r\n      };\r\n\r\n      this.wsConnection.onmessage = (event) => {\r\n        try {\r\n          const target = JSON.parse(event.data);\r\n          const currentTargets = this.targetsSignal();\r\n          const updatedTargets = [target, ...currentTargets].slice(0, 50); // Keep last 50 targets\r\n          this.targetsSignal.set(updatedTargets);\r\n        } catch (error) {\r\n          console.error('Error parsing WebSocket message:', error);\r\n        }\r\n      };\r\n\r\n      this.wsConnection.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        this.isConnectedSignal.set(false);\r\n      };\r\n\r\n      this.wsConnection.onclose = () => {\r\n        console.log('WebSocket connection closed');\r\n        this.isConnectedSignal.set(false);\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Failed to connect to WebSocket:', error);\r\n      this.isConnectedSignal.set(false);\r\n    }\r\n  }\r\n\r\n  stopWebSocketStream(): void {\r\n    if (this.wsConnection) {\r\n      this.wsConnection.close();\r\n      this.wsConnection = undefined;\r\n    }\r\n    this.isConnectedSignal.set(false);\r\n  }\r\n\r\n  // REST API methods\r\n  getTargets(): Observable<{targets: Target[], count: number}> {\r\n    return this.http.get<{targets: Target[], count: number}>(`${this.apiUrl}/targets`);\r\n  }\r\n\r\n  addTargets(targets: Target[]): Observable<any> {\r\n    return this.http.post(`${this.apiUrl}/targets`, { targets });\r\n  }\r\n\r\n\r\n\r\n  // Clear all targets\r\n  clearTargets(): void {\r\n    this.targetsSignal.set([]);\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}